{
    "version": "https://jsonfeed.org/version/1",
    "title": "𝕺𝖚𝖗 𝕷𝖎𝖋𝖊 • All posts by \"汇编语言\" tag",
    "description": "记录生活 | 为众人抱薪者,不可使其扼于风雪",
    "home_page_url": "https://pangbai.work",
    "items": [
        {
            "id": "https://pangbai.work/IT/Re4/",
            "url": "https://pangbai.work/IT/Re4/",
            "title": "汇编学习-汇编指令",
            "date_published": "2023-09-25T04:19:19.000Z",
            "content_html": "<p>常用 x86 汇编指令，以及其含义</p>\n<span id=\"more\"></span>\n<h2 id=\"move\"><a class=\"anchor\" href=\"#move\">#</a> Move</h2>\n<p>move 操作对象可以是<br />\n寄存器 &lt;- 寄存器<br />\n寄存器 &lt;- 内存<br />\n寄存器 &lt;- 立即数<br />\n内存 &lt;- 寄存器<br />\n内存 &lt;- 立即数</p>\n<details class=\"info\"><summary></summary><div>\n<p>立即数可以看成 C 语言里的常数 (大概吧)</p>\n</div></details>\n<p>是进行数据操作的指令</p>\n<h2 id=\"lea\"><a class=\"anchor\" href=\"#lea\">#</a> Lea</h2>\n<p>加载有效地址到寄存器。<br />\n加载地址也可以用 mov 指令，但是在有些情况下 lea 会很简便</p>\n<h2 id=\"关于符号\"><a class=\"anchor\" href=\"#关于符号\">#</a> 关于符号 []</h2>\n<p>对于操作数，经常可以看到 []。<br />\n我总是很困惑这个符号，因为它有时候表示解引用，操作的是内存的值，有时候又是表示地址。现在来梳理一下吧。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"><span>例子1</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov     <span class=\"token register variable\">eax</span>, <span class=\"token operator\">[</span><span class=\"token register variable\">eax</span><span class=\"token operator\">+</span><span class=\"token number\">18h</span><span class=\"token operator\">]</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> lea     <span class=\"token register variable\">edx</span>, <span class=\"token operator\">[</span><span class=\"token register variable\">eax</span><span class=\"token operator\">+</span><span class=\"token number\">28h</span><span class=\"token operator\">]</span></pre></td></tr></table></figure><p>关于上面的汇编，未执行前 eax 里装的是数组的首地址。mov 第二操作数是数组里的元素，而 lea 的第二操作数是一个地址。同样的一个 []，在 mov 为解引用，在 lea 却只是一个简单的加法运算。</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"><span>例子2</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>MOV <span class=\"token register variable\">EBX</span>, <span class=\"token operator\">[</span>MY_TABLE<span class=\"token operator\">]</span>     <span class=\"token comment\">; Effective Address of MY_TABLE in EBX</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>MOV <span class=\"token operator\">[</span><span class=\"token register variable\">EBX</span><span class=\"token operator\">]</span>, <span class=\"token number\">110</span>          <span class=\"token comment\">; MY_TABLE[0] = 110</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ADD <span class=\"token register variable\">EBX</span>, <span class=\"token number\">2</span>              <span class=\"token comment\">; EBX = EBX +2</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>MOV <span class=\"token operator\">[</span><span class=\"token register variable\">EBX</span><span class=\"token operator\">]</span>, <span class=\"token number\">123</span></pre></td></tr></table></figure><p>这个例子来自<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzNzY2hvb2xzLmNuL2Fzc2VtYmx5L2Fzc2VtYmx5X2FkZHJlc3NpbmdfbW9kZXMuaHRtbA==\"> w3school 寻址模式</span><br />\n按照注释理解，[MY_TABLE] 是一个数组地址，<br />\n[EBX] 却是解引用。<br />\n查找了一下资料，这里进行一下梳理吧 (不知道对不对，欢迎指正)。</p>\n<h3 id=\"对于lea-装入有效地址的指令\"><a class=\"anchor\" href=\"#对于lea-装入有效地址的指令\">#</a> <strong>对于 lea</strong><em>: 装入有效地址的指令</em></h3>\n<ul>\n<li>第一个操作数一定是寄存器</li>\n<li>第二个操作数可以是寄存器，变量，地址表达式</li>\n</ul>\n<p><em>重点在第二个操作数</em></p>\n<ul>\n<li>\n<p><strong>第二个操作数为变量时</strong><br />\n因为是进行地址加载的指令，[] 加不加都没关系，解释为 DS: 变量偏移，这时的变量都是解释为地址 (也就是变量偏移), 不会取变量的值</p>\n</li>\n<li>\n<p><strong>第二个操作数为寄存器或者地址表达式时</strong><br />\n必须要加 [] , 因为 lea 是加载地址的第二个操作数一定是地址，也就是 DS: 寄存器的值，这里的 [] 就是取寄存器的值，并没有解引用 (地址表达式也是表达式的值，并没有引用地址数据)。</p>\n</li>\n</ul>\n<h3 id=\"对于mov-进行数据操作的指令\"><a class=\"anchor\" href=\"#对于mov-进行数据操作的指令\">#</a> <strong>对于 mov</strong><em>: 进行数据操作的指令</em></h3>\n<p>两个操作数的类型是不固定的，我们假设操作数第一个是个寄存器。</p>\n<ul>\n<li><strong>第二个操作数为变量时</strong></li>\n</ul>\n<p>因为是进行数据操作的指令，不管变量加不加 [] 都是相同的效果，都是解引用，获取变量的数据到寄存器。栗子 2 的第一条代码就明白了，[] 是不用管的。</p>\n<ul>\n<li><strong>第二个操作数为寄存器或者地址表达式</strong></li>\n</ul>\n<p>第二个操作数是寄存器的时候，就是我们常见的情况了，加 [] 是把寄存器里的地址数据取出来解引用得到地址里的数据，把地址里的数据装入寄存器。不加 [] 是直接装寄存器的数据，不管数据是一个地址还是其他什么东西。</p>\n<p>第二个操作数是地址表达式一定要加 [] ，这个可以理解 (你找不到不加 [] 的地址表达式), 这时是解引用，把数据装入寄存器。你可能要问了，如果我想把地址表达的值装入寄存器呢？我们有两种方法</p>\n<ul>\n<li>方法一：使用 lea 指令 (也就是 lea 的第二种情况)。</li>\n<li>方法二：先用 add 之类的指令把地址表达式的值算出来，然后值给到第二次操作数的寄存器 ebx, 再执行 mov eax, ebx</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>对于汇编指令来说 [] 只是一个标记，并没有特定的含义，具体含义应该看其所在的对应指令。除了上面的两个指令使用 [] 外，在编写汇编代码时，甚至可以用 <code>变量[]</code>  来使用数组元素 (有点像 c 语言了), 当然在 ida 几乎看不到这样的东西，这只是一个语法糖。把 mov 和 lea 理解透了才能清楚汇编执行时倒是操作的是地址还是数据。</p>\n",
            "tags": [
                "IT",
                "汇编语言"
            ]
        },
        {
            "id": "https://pangbai.work/IT/re3/",
            "url": "https://pangbai.work/IT/re3/",
            "title": "汇编学习-汇编语法",
            "date_published": "2023-09-24T04:19:19.000Z",
            "content_html": "<p>汇编语法</p>\n<span id=\"more\"></span>\n<h1 id=\"基础语法\"><a class=\"anchor\" href=\"#基础语法\">#</a> 基础语法</h1>\n<h2 id=\"标号\"><a class=\"anchor\" href=\"#标号\">#</a> 标号</h2>\n<p>为一个段命名，标号指代了一个地址，如 codesg</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>codesg segment</pre></td></tr></table></figure><p>这个段由以下命令定义结束</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>codesg ends</pre></td></tr></table></figure><h2 id=\"声明段的类型\"><a class=\"anchor\" href=\"#声明段的类型\">#</a> 声明段的类型</h2>\n<p>段的类型可能是代码也可能是数据，需要加以声明 <code>assume</code></p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>assume <span class=\"token register variable\">cs</span>:codesg</pre></td></tr></table></figure><h2 id=\"几种结束\"><a class=\"anchor\" href=\"#几种结束\">#</a> 几种结束</h2>\n<ul>\n<li>段结束</li>\n</ul>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>段名 ends</pre></td></tr></table></figure><ul>\n<li>程序结束</li>\n</ul>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>end</pre></td></tr></table></figure><ul>\n<li>程序返回</li>\n</ul>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ax</span>, <span class=\"token number\">4c00H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre> int <span class=\"token number\">21H</span></pre></td></tr></table></figure><h2 id=\"示例程序\"><a class=\"anchor\" href=\"#示例程序\">#</a> 示例程序</h2>\n<p>编写 1.asm</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>assume <span class=\"token register variable\">cs</span>:codesg</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   codesg segment</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     mov <span class=\"token register variable\">ax</span>, <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>     add <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>     add <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>     mov <span class=\"token register variable\">ax</span>, <span class=\"token number\">4c00H</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     int <span class=\"token number\">21H</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   codesg ends</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   end</pre></td></tr></table></figure><p>执行编译和链接</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>masm <span class=\"token number\">1</span>.asm</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">link</span> <span class=\"token number\">1</span>.obj</pre></td></tr></table></figure><h2 id=\"设置程序入口\"><a class=\"anchor\" href=\"#设置程序入口\">#</a> 设置程序入口</h2>\n<p>用一个标号标识，用 <code>end 标号</code> 结束程序入口</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>assume <span class=\"token register variable\">cs</span>:codesg</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   codesg segment</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token label function\">start:</span>    mov <span class=\"token register variable\">ax</span>, <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            add <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>            add <span class=\"token register variable\">ax</span>, <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>            mov <span class=\"token register variable\">ax</span>, <span class=\"token number\">4c00H</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            int <span class=\"token number\">21H</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   codesg ends</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   end start</pre></td></tr></table></figure><details class=\"info\"><summary>小知识</summary><div>\n<p>程序被加载到内存后，还会在其前方设置一段内存设置代码 (psp) 用于与程序通信，运行时并不会从程序直接开始，而是从 psp 开始</p>\n</div></details>\n<h2 id=\"数据的存储\"><a class=\"anchor\" href=\"#数据的存储\">#</a> 数据的存储</h2>\n<p>对于 x86CPU, 数据在内存中是小端存储<br />\n我们规定关于一个地址编号<br />\n 0x0001-&gt;0xFFFF<br />\n 前为低地址，后为高地址，是按内存编号的方向区分<br />\n对于数据 0x1234 (十六进制数据，需要 16 个比特位存储)<br />\n 需要拆分为两个字节存储</p>\n<details class=\"info\"><summary>r 注意</summary><div>\n<p>在计算机中一个字节的存储可以完整存储，是没有大小端之分的</p>\n</div></details>\n<p>这个数据需要在两个相邻地址中存储，这就涉及到了谁先谁后的问题。<br />\n大端存储：高位数据 0x1200 需要存储在低地址，低位数据 0x34 需要存储在高地址。<br />\n小端存储：低位数据存储在低地址，高位数据存储在高地址。</p>\n<p>x86CPU 小端存储的数据读入 CPU 寄存器的时候都会自动反转字节</p>\n",
            "tags": [
                "汇编语言"
            ]
        },
        {
            "id": "https://pangbai.work/IT/re2/",
            "url": "https://pangbai.work/IT/re2/",
            "title": "汇编学习-CPU寄存器",
            "date_published": "2023-09-23T04:19:19.000Z",
            "content_html": "<p>计算机 CPU 与寄存器知识</p>\n<span id=\"more\"></span>\n<h2 id=\"寄存器与物理地址\"><a class=\"anchor\" href=\"#寄存器与物理地址\">#</a> 寄存器与物理地址</h2>\n<p>寄存器一般为 16 位，而地址总线可能大于 16<br />\n8086 处理器，寄存器为 16，地址总线为 20<br />\n 如果我们想要寻址，该怎么办呢？<br />\nCPU 中存在好几个段寄存器 CS,DS,SS,ES 用于提供段地址。</p>\n<details class=\"info\"><summary>段寄存器</summary><div>\n<p>CS 是代码段寄存器<br />\n DS 是数据地址<br />\n SS 是堆栈地址<br />\n ES 提供额外的地址 (什么都可以有)</p>\n</div></details>\n<p>我们需要理由 <code>段地址</code> 和 <code>偏移量</code> 进行操作，这两个数据存储在两个寄存器中，段地址就是物理地址的头部，而偏移量是物理地址的尾部，通过将段地址左移再和偏移量相加，就可以得到完整地址。<br />\n<span class=\"label info\">举个栗子</span> 段地址 16 进制若为 21F0H，偏移地址 0060H，此时段地址左移 1 位<span class=\"spoiler\" title=\"你知道得太多了\">即 x16, 也是加 4 位的意思，此时共 20 位</span>为 21F00H，这个时候加上偏移地址 0060H 可以得到 21F60H 这个 20 位地址<br />\n同一地址可以用不同组段地址 + 偏移量表示:<br />\n2000H + 1F60H -&gt;21F60H<br />\n2100H + 0F60H -&gt;21F60H<br />\n1F00H + 2F60H -&gt;21F60H<br />\n 以上都可表示为  <code>段地址:偏移地址</code> <br />\n IP 寄存器是指令指针寄存器，用于提供偏移地址。<br />\nCS 和 IP 最为关键，他们指示 CPU 要读取指令的地址，当 CS:IP 指向哪里，代码就执行到哪里</p>\n<details class=\"danger\"><summary>小测试</summary><div>\n<p>2AE3:3=?<br />\n3:0B16=?<br />\n 答案是 2AE33 和 00B46</p>\n</div></details>\n<h2 id=\"cpu执行指令过程\"><a class=\"anchor\" href=\"#cpu执行指令过程\">#</a> CPU 执行指令过程</h2>\n<p>首次执行<br />\n CS:IP -&gt; 地址加法器 -&gt; CPU 输入输出线路 -&gt; 存储器地址 -&gt; 获取数据 (可能是多个字节) -&gt; CPU 输入输出线路 -&gt; CPU 执行控制器<br />\n第二次执行<br />\n CS:IP+(上次获取到的字节数) -&gt; 地址加法器 -&gt; CPU 输入 ......<br />\n 即  <code>新的指令执行IP=旧IP+指令读取长度</code> 。</p>\n<details class=\"info\"><summary>小知识</summary><div>\n<p>处理器通电后 CS 会被初始化为 FFFFH,IP 被初始化为 000H<br />\n 即计算机开机会执行内存中 FFFF0H 的指令 (这是计算机执行第一条指令)</p>\n</div></details>\n<h2 id=\"debug修改寄存器\"><a class=\"anchor\" href=\"#debug修改寄存器\">#</a> debug 修改寄存器</h2>\n<p>Windows 打开 cmd 进入 debug</p>\n<ul>\n<li>R 查看修改寄存器内容</li>\n<li>D 查看内存内容</li>\n<li>E 改写内存内容</li>\n<li>U 将内存中机械指令翻译成汇编指令</li>\n<li>T 执行一行机械指令 (从 CS:IP 开始)</li>\n<li>A 以汇编语言在内存写入机械指令<br />\n以上指令不区分大小写</li>\n</ul>\n<h2 id=\"ds寄存器和address\"><a class=\"anchor\" href=\"#ds寄存器和address\">#</a> DS 寄存器和 [address]</h2>\n<p>获取指定地址的数据<br />\n将段地址存入 ds, 再通过偏移 [address] 获取数据</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ax</span> , <span class=\"token number\">1000H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">ds</span> , <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token register variable\">al</span> , <span class=\"token operator\">[</span><span class=\"token number\">0</span><span class=\"token operator\">]</span></pre></td></tr></table></figure><p>因为计算机 CPU 设计问题，不能直接使用 <code>mov ds , 1000H</code> <br />\n 改写数据</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mov <span class=\"token register variable\">ax</span> , <span class=\"token number\">1000H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">ds</span> , <span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token operator\">[</span><span class=\"token number\">0</span><span class=\"token operator\">]</span>, <span class=\"token register variable\">al</span></pre></td></tr></table></figure><p>需要注意的是：如果你使用 16 位寄存器 (ax) 进行操作如 <code>mov ax , [0]</code>  那 ax 中将会存在 16 位数据，这些数据来自 [1] 和 [0], 如果你使用 8 位寄存器 (al) 进行操作如 <code>mov al,[0]</code>  那 al 中将会存在八位数据 (仅仅来自 [0])</p>\n<h2 id=\"栈与寄存器\"><a class=\"anchor\" href=\"#栈与寄存器\">#</a> 栈与寄存器</h2>\n<p>栈是一段特殊内存，具有先进先出的规则，栈顶是栈的最高的存有数据的内存地址<br />\n段寄存器 SS 存放栈顶段地址<br />\n寄存器 SP 存放栈顶的偏移地址<br />\n任意时刻 SS:SP 指向栈顶地址<br />\n栈在代码编译的时候自动分配和销毁，每个函数都会有一个单独的栈，在函数执行时创建，执行完毕后销毁，栈的存在确保函数的相对封闭与数据的独立，当一个一个函数调用另一个函数时，调用者数据会进入栈中保存，被调用者执行完毕后，再从栈中读取数据继续执行，数据入栈和出栈顶顺序相反<br />\n用 push 命令入栈数据，pop 命令出栈数据<br />\n push 命令会根据当前的栈顶执行进行操作，数据入栈前会将偏移地址减去数据长度 (此处为 2, 因为寄存器为内存单元两倍), 然后再存入数据，而 pop 顺序则相反</p>\n<figure class=\"highlight nasm\"><figcaption data-lang=\"NASM\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>如果要在<span class=\"token number\">10000H</span>存入数据<span class=\"token number\">2266H</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mov <span class=\"token register variable\">ax</span>,<span class=\"token number\">1000H</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>mov <span class=\"token register variable\">ss</span>,<span class=\"token register variable\">ax</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>mov <span class=\"token register variable\">sp</span>,<span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>mov, <span class=\"token register variable\">ax</span>,<span class=\"token number\">2266H</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>push <span class=\"token register variable\">ax</span></pre></td></tr></table></figure><p>栈地址排列为上低下高，初始栈顶执行最高地址 + 1,CPU 只知道栈在哪，不会知道栈有多大，需要开发者注意越界</p>\n",
            "tags": [
                "汇编语言"
            ]
        },
        {
            "id": "https://pangbai.work/IT/re1/",
            "url": "https://pangbai.work/IT/re1/",
            "title": "汇编学习第一天",
            "date_published": "2023-09-23T02:39:19.000Z",
            "content_html": "<p>计算机 CPU 相关基础知识</p>\n<span id=\"more\"></span>\n<h2 id=\"基本知识\"><a class=\"anchor\" href=\"#基本知识\">#</a> 基本知识</h2>\n<ul>\n<li>\n<p>所有编译语言都是将可读性描述转化为二进制机械语言进行执行<br />\n通用计算机语言 -&gt; 汇编语言 -&gt; 二进制语言</p>\n</li>\n<li>\n<p>计算机几乎所有组件都有存储器<br />\n CPU 最直接的存储器是寄存器</p>\n</li>\n<li>\n<p>CPU 可以对所有存储器读写<br />\n CPU 接有直接到达各个计算机部件的电路<br />\n CPU 可以对存储器进行三类交互</p>\n</li>\n</ul>\n<details class=\"danger\"><summary>三种交互类型</summary><div>\n<p><span class=\"label info\">1</span> 地址信息 (通过地址总线)<br />\n<span class=\"label info\">2</span> 控制信息 (通过控制总线)<br />\n<span class=\"label info\">3</span> 数据信息 (通过数据总线)</p>\n</div></details>\n<ul>\n<li>程序执行流程<br />\n硬盘文件 -&gt; 虚拟内存 -&gt;CPU</li>\n<li>存储器芯片<br />\n分为 RAM 和 ROM</li>\n</ul>\n<details class=\"info\"><summary>存储器芯片分类</summary><div>\n<p>内存 -&gt;RAM<br />\n 接口 -&gt;RAM<br />\nbios-&gt;ROM</p>\n</div></details>\n<ul>\n<li>内存地址空间 (物理地址)<br />\n 逻辑上所有计算机接入设备都是相连的一大块<br />\n CPU 可见的是一大块的存储器 (包含内存，显卡，网卡...)<br />\n 系统为存储器分配地址空间<br />\n<span class=\"label danger\">举个栗子</span> 主随机存储器地址为 0<sub>7FFFH, 显存地址为 8000H</sub>9FFFH, 各 ROM 地址为 A000H~FFFFH</li>\n</ul>\n<h2 id=\"地址总线与cpu寻址\"><a class=\"anchor\" href=\"#地址总线与cpu寻址\">#</a> 地址总线与 CPU 寻址</h2>\n<p>CPU 到内存的总线有很多条 (逻辑上), 具体数目与 CPU 有关，一条总线可以传输一位数据 (0/1), 将所有总线的数据联合起来就组成了地址信息，主流处理器分 32 位和 64 位 (也叫地址宽度), 在地址总线上就对应了 CPU 能访问到的地址数目 2<sup>32 和 2</sup>64。<br />\n<span class=\"label info\">举个栗子</span>当 CPU 从地址总线发送数据 (11010000...) 到内存，内存会定位到这个地址，这个地址的所在的内存单元数据 (通常为 1byte) 也就被寻找到了。</p>\n<h2 id=\"数据总线与数据传输\"><a class=\"anchor\" href=\"#数据总线与数据传输\">#</a> 数据总线与数据传输</h2>\n<p>数据总线的宽度决定速度传输速度<br />\n 8088CPU 是 8 位的，一次可以传输 8 位数据<br />\n 8086CPU 是 16 位的，一次可以传输 16 位数据</p>\n<h2 id=\"控制总线\"><a class=\"anchor\" href=\"#控制总线\">#</a> 控制总线</h2>\n<p>控制总线发送控制信息 (通常是读和写)<br />\n 控制接入电脑的硬件。</p>\n<h2 id=\"cpu概述\"><a class=\"anchor\" href=\"#cpu概述\">#</a> CPU 概述</h2>\n<p>一个典型 CPU 由 <code>运算器</code> ， <code>控制器</code> ， <code>寄存器</code> 组成，这些部件靠 CPU 内部总线相连。</p>\n<h2 id=\"寄存器概述\"><a class=\"anchor\" href=\"#寄存器概述\">#</a> 寄存器概述</h2>\n<p>x86 寄存器一般是 16 位的，可以存放两个字节 (等于一个字)，AX,BX,CX,DX 存储一般性数据，可以分为两个独立的 8 位使用，称为通用寄存器<br />\n通用寄存器一般为 8 个，其他寄存器可以有若干<br />\n AX 等带 X 后缀的都为 16 位，而 EAX 之类为 32 位<br />\n通用寄存器可以分为高位和地位如 AH 和 AL,BH 和 BL (用于兼容旧系统)</p>\n",
            "tags": [
                "汇编语言"
            ]
        }
    ]
}