---
title: 栈溢出基础
categories: CTF
tags:
- 汇编
---
我就学学吧,开开眼界也好
<!--more-->
# 重要芝士
PLT表存放跳转相关指令，GOT表存放外部函数（符号）地址
plt在ida是蓝色的，got在ida是粉色的，plt可跳转got表
# 32位调用约定
 - [x] 普通函数调用
 参数按函数签名由右往左入栈,参数在返回地址的前
 - [x] 内核调用
 调用号用eax保存，其他参数保存在ebx,ecx,edx,esi,edi,ebp,多余的参数入栈,最后执行`int 0x80`
# 64位调用约定
 - [x] 普通函数调用约定
 参数依次保存在rdi,rsi,rdx,rcx,r8,r9,多余的一律入栈，入栈参数在返回地址前
 - [x] 内核调用
 调用号用rax保存，其他参数保存和普通调用一样， 最后执行`syscall `
# 特殊调用约定
`__stdcall：`Windows API 默认函数调用协议

函数参数从右到左入栈，调用结束被调者负责清理压入的参数，在 Windows 中出现的比较多

`__cdecl:` C/C++ 默认函数调用协议

函数参数从右到左入栈，调用结束后调用者负责清理压入的参数，x86 平台大多都是这个

`__fastcall:` 对性能要求高的场合的调用方法

从左开始将不大于四个字节的参数放入 eax 到 edx 寄存器，其余参数从右向左入栈

`__thiscall: `为类方法专门优化的调用约定
如果参数个数确定
this 指针会被放在 ecx 里，其余参数右向左压栈
# Canary保护
Canary保护是在栈中插入应该随机数据的操作。一旦程序跳转时检测到canary发生改变就说明栈发生了溢出，程序会直接终止
这段数据有下面的特点
 - [x] 低位字节为0x00,这个是为了防止canary被字符串输出函数泄露(c语言字符串到0x00就不会输出了)
 - [x] 数据是随机产生的，只会保存两份，一份在gs:0x14中,另一份就是在栈中
 
 
 绕过Canary的话，就要获取到栈中Canary的数据，在栈溢出时使用canary原本的数据填充canary的地址，再溢出到ebp。具体操作请百度Canary泄露